# Hardware Track
This challenge requires you to implement an L2 norm accelerator using Verilog or VHDL hardware description languages.
Implementation should use AXI-Stream interfaces, an open-source standard, for input and output.

### Project Structure
```bash
hardware/
│
│
├── sources/
│       ├── L2NormAXIS.sv   # Template for top module                 ... Participants need to implement this
│       ├── . . . .   .sv   # Other .sv .v or .vhd files that participants can implement ... Participants need to implement this
│       ├── . . . .   .v    # Other .sv .v or .vhd files that participants can implement ... Participants need to implement this
│       ├── . . . .   .vhd  # Other .sv .v or .vhd files that participants can implement ... Participants need to implement this
│       └── vivado_top.sv   # Top module for FPGA implementation                     ... Fully provided by SEMRON
│                           # Includes: clock generation, reset synchronizer, logic analyzer, L2NormAXIS module.
│
├── testbench/              # testbench directory                 ... Fully provided by SEMRON
│       └── tb.cpp          # c++ testbench to wrap L2NormAXIS module. It is provided to verilator.
│                           # This testbench also calculates MSE of the L2 approximation compared to double
│                           # precision implementation of L2.
│
├── vivado_local/           # vivado project directory                 ... Fully provided by SEMRON
│       ├── const_0.xdc     # FPGA constraints                         ... Fully provided by SEMRON
│       ├── Makefile        # Makefile to initialize vivado project    ... Fully provided by SEMRON
│       └── proj_init.tcl   # TCL script to initialize vivado project  ... Fully provided by SEMRON
│
├── .gitignore
├── Makefile.toolchain      # Makefile to build needed tools
├── build-toolchain/        # Build directory for toolchain
│       ├── ...
│       └── env.sh          # source this to set up the toolchain in a shell (generated by Makefile.toolchain)
└── README.md
```

## Toolchain

### Install Verilator

#### Install from your distribution

Many distributions already provide a package for verilator.

```bash
# Ubuntu
sudo apt-get install -y verilator

# Fedora
sudo dnf instll verilator
```

See a list of all verilator distro packages
[here](https://pkgs.org/search/?q=verilator).

#### Install from source

The verilator versions provided with some distributions are significantly
outdated.
If you run into problems we provide a Makefile to build Verilator from source.
We provide a Makefile to build Verilator from source.
You only need to run the following to build it:

##### Dependencies

###### Ubuntu

```bash
sudo apt-get install -y bison debhelper-compat \
     dh-sequence-sphinxdoc flex latexmk libfl-dev libsystemc-dev \
     help2man python3.12 python3-sphinx python3-sphinx-rtd-theme \
     tex-gyre texlive-latex-extra
```

##### Building

```bash
# cd into the hardware/ directory
make -f Makefile.toolchain

# now, you just have to source the script which puts the verilator you just
# built on any shell where you want to call verilator
source build-toolchain/env.sh
```

## Extra Tools

### GTKWave

[GTKWave](https://gtkwave.sourceforge.net) is used to view debug traces of simulations.

Most Linux distributions have a package simply named `gtkwave` in their repos.

For a universal install on any Linux distro, you can simply use [Flathub](https://flathub.org/apps/io.github.gtkwave.GTKWave).

After installing, you can use it to open `.vcd` files.

### Surfer (VCD Viewer)

A nice modern alternative to GTKWave is [Surfer](https://surfer-project.org),
you can simply download a binary for most systems on their website.
You can even run it in your web browser. (But beware that this might be slower)

## Yosys (optional)

### Install from Linux distribution packages

Yosys is a free and open-source framework for Verilog synthesis and verification.
It can be used to synthesize Verilog designs into gate-level netlists, perform
logic optimization, and generate testbenches.

We will only use it to [synthesize](https://en.wikipedia.org/wiki/Logic_synthesis)
the hardware description language, into a [gate level](https://en.wikipedia.org/wiki/Logic_gate)
[netlist](https://en.wikipedia.org/wiki/Netlist) which will act as a suitable
proxy for design efficiency. (area, complexity, to some extent even energy efficiency)

Some Linux distributions (Ubuntu, Fedora, Debian, Arch) have packages for
yosys in their official repos. (under the name `yosys`)

### Build from source

If you are not able to install Yosys from

Install build dependencies:
```bash

# for Ubuntu (24.04)
sudo apt install debhelper-compat dh-python tcl-dev libreadline-dev libbz2-dev \
    zlib1g-dev bison flex gawk git libffi-dev pkgconf txt2man iverilog python3 \
    python3-setuptools libcxxopts-dev gtkwave texlive-base \
    texlive-plain-generic texlive-fonts-recommended texlive-fonts-extra \
    texlive-latex-base texlive-latex-extra texlive-font-utils texlive-science \
    texlive-publishers texlive-bibtex-extra tex-gyre latexmk lmodern graphviz \
    faketime pdf2svg python3-sphinx python3-sphinx-press-theme \
    python3-sphinxcontrib.bibtex python3-click

# for Fedora
sudo dnf install make gcc-c++ cxxopts-devel bison flex readline-devel \
    pkgconfig tcl-devel libffi-devel yosyshq-abc iverilog python3.12 \
    python3-devel txt2man gtkwave

# cd into the hardware/ directory
make -f Makefile.toolchain yosys-install

# just as for the Verilator build, you now need to source build-toolchain/env.sh
```

### Generate a stats file

You can generate a statistics file for your current design by running the
following:

```bash
make stats MODE=<..>

# you can find the output in yosys-results/
```

## netlistsvg

[netlistsvg](https://github.com/nturley/netlistsvg) is a project which is able
to generate schematics from the netlists generated by yosys.

It is not strictly necessary, but can be a fun and insightful way to see how
code changes on the [RTL](https://en.wikipedia.org/wiki/Register-transfer_level)
affect the hardware which is generated.

It is installed through `npm`, you should install `npm` from your distributions
repo.

```bash
# When you have npm installed, you can install it as follows:
make -f Makefile.toolchain netlistsvg-install

# just like Verilator you will now need to source build-toolchain/env.sh
```

To generate a nice visual netlist, run the following command:

```bash
make visualize MODE=<..>
# you can find the output in yosys-results/

# if you want to generate a png instead of an svg, just add
# VIZ_EXT=png
# (you need to have imagemagick installed for this to work)
```

---

## First Stage: Implementation:

Under the ```sources\``` directory, there is a template for top-level design.
Using this top-level file (or you can convert it to VHDL) implement an L2 Norm
calculation accelerator. Inputs and outputs of the module are AXI-Stream.

The vector dimension that we calculate L2 Norm on is an arbitrary multiple of 8.
Module should accept data in int8 format. Results should be in 32-bit format.
It can be float32 or a fixed-point 32 with arbitrary number of fraction bits.

Input stream is 64 bits wide, hence can accept 8 input elements at a time.
```tuser``` and ```tkeep``` is not necessary to implement.
```tlast``` indicates that it is the last beat for this vector.
This means vector size is dynamic and end of vector is indicated by ```tlast```.

Run this command to test your design if you have float outputs:

```bash
make run MODE=float
```

or fixed point output:

```bash
make run MODE=fixed [FIXED_WIDTH=<number of fraction bits>]
```

This is the end of Checkpoint 1. You can see the mean square error of the implementation compared to double precision output.
You can also see the latency of each calculation and average latency.

## Second Stage: Synthesis, Place and Route:

After finalizing the design, participants can push their design to a branch.
We will synthesize your design using our local vivado license and provide you the timing and utilization report.

If timing is failing or resource consumption is too high, further optimization is required.
Resource utilization is also part of the score calculation.

## Third Stage: Deployment:

In this stage, no additional effort is required. We will generate bitstream for FPGA and deploy it to prove design is working.
